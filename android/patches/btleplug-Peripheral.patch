--- a/android/lib/src/main/java/com/nonpolynomial/btleplug/android/impl/Peripheral.java
+++ b/android/lib/src/main/java/com/nonpolynomial/btleplug/android/impl/Peripheral.java
@@ -5,15 +5,21 @@
 import android.bluetooth.BluetoothDevice;
 import android.bluetooth.BluetoothGatt;
 import android.bluetooth.BluetoothGattCallback;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattDescriptor;
-import android.bluetooth.BluetoothGattService;
+import android.bluetooth.BluetoothGattCharacteristic;
+import android.bluetooth.BluetoothGattDescriptor;
+import android.bluetooth.BluetoothGattService;
+import android.os.Handler;
+import android.os.Looper;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 import java.util.Queue;
+import java.util.Set;
 import java.util.UUID;
 
 import io.github.gedgygedgy.rust.future.Future;
@@ -22,8 +28,8 @@
 import io.github.gedgygedgy.rust.stream.Stream;
 
 @SuppressWarnings("unused") // Native code uses this class.
-class Peripheral {
-    private static final UUID CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR = new UUID(0x00002902_0000_1000L, 0x8000_00805f9b34fbL);
+class Peripheral {
+    private static final UUID CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR = new UUID(0x00002902_0000_1000L, 0x8000_00805f9b34fbL);
 
     private final BluetoothDevice device;
     private final Adapter adapter;
@@ -33,8 +39,16 @@
 
     private final Queue<Runnable> commandQueue = new LinkedList<>();
     private final LinkedList<WeakReference<QueueStream<BluetoothGattCharacteristic>>> notificationStreams = new LinkedList<>();
+    private final LinkedList<BluetoothGattCharacteristic> notificationBacklog = new LinkedList<>();
+    private final Map<UUID, LinkedList<SimpleFuture<byte[]>>> pendingNotificationReads = new HashMap<>();
+    private final Set<UUID> subscribedNotificationUuids = new HashSet<>();
     private boolean executingCommand = false;
     private CommandCallback commandCallback;
+    private final Handler handler = new Handler(Looper.getMainLooper());
+    private static final int MAX_NOTIFICATION_BACKLOG = 256;
+    private static final int WRITE_NO_RESPONSE_MAX_RETRIES = 8;
+    private static final long WRITE_NO_RESPONSE_RETRY_DELAY_MS = 12L;
+    private static final long DISCONNECT_FALLBACK_DELAY_MS = 1200L;
 
     public Peripheral(Adapter adapter, String address) {
         this.device = BluetoothAdapter.getDefaultAdapter().getRemoteDevice(address);
@@ -57,10 +71,19 @@
                                 }
 
                                 if (newState == BluetoothGatt.STATE_CONNECTED) {
-                                    Peripheral.this.wakeCommand(future, null);
+                                    if (!gatt.requestMtu(247)) {
+                                        Peripheral.this.wakeCommand(future, null);
+                                    }
                                 }
                             });
                         }
+
+                        @Override
+                        public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {
+                            Peripheral.this.asyncWithFuture(future, () -> {
+                                Peripheral.this.wakeCommand(future, null);
+                            });
+                        }
                     };
 
                     if (this.connected) {
@@ -85,36 +108,53 @@
     }
 
     @SuppressLint("MissingPermission")
-    public Future<Void> disconnect() {
-        SimpleFuture<Void> future = new SimpleFuture<>();
-        synchronized (this) {
-            this.queueCommand(() -> {
-                this.asyncWithFuture(future, () -> {
-                    if (!this.connected) {
-                        Peripheral.this.wakeCommand(future, null);
-                    } else {
-                        this.setCommandCallback(new CommandCallback() {
-                            @Override
-                            public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
-                                Peripheral.this.asyncWithFuture(future, () -> {
-                                    if (status != BluetoothGatt.GATT_SUCCESS) {
-                                        throw new RuntimeException("Unable to disconnect");
+    public Future<Void> disconnect() {
+        SimpleFuture<Void> future = new SimpleFuture<>();
+        synchronized (this) {
+            this.queueCommand(() -> {
+                this.asyncWithFuture(future, () -> {
+                    if (!this.connected) {
+                        Peripheral.this.wakeCommand(future, null);
+                    } else {
+                        final CommandCallback disconnectCallback = new CommandCallback() {
+                            @Override
+                            public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
+                                Peripheral.this.asyncWithFuture(future, () -> {
+                                    if (status != BluetoothGatt.GATT_SUCCESS) {
+                                        throw new RuntimeException("Unable to disconnect");
                                     }
 
-                                    if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-                                        Peripheral.this.gatt.close();
-                                        Peripheral.this.gatt = null;
-                                        Peripheral.this.wakeCommand(future, null);
-                                    }
-                                });
-                            }
-                        });
-                        this.gatt.disconnect();
-                    }
-                });
-            });
-        }
-        return future;
+                                    if (newState == BluetoothGatt.STATE_DISCONNECTED) {
+                                        Peripheral.this.gatt.close();
+                                        Peripheral.this.gatt = null;
+                                        Peripheral.this.wakeCommand(future, null);
+                                    }
+                                });
+                            }
+                        };
+                        this.setCommandCallback(disconnectCallback);
+                        this.gatt.disconnect();
+                        this.handler.postDelayed(() -> {
+                            synchronized (Peripheral.this) {
+                                if (Peripheral.this.commandCallback == disconnectCallback) {
+                                    Peripheral.this.connected = false;
+                                    if (Peripheral.this.gatt != null) {
+                                        Peripheral.this.gatt.close();
+                                        Peripheral.this.gatt = null;
+                                    }
+                                    Peripheral.this.adapter.onConnectionStateChanged(
+                                            Peripheral.this.device.getAddress(),
+                                            false
+                                    );
+                                    Peripheral.this.wakeCommand(future, null);
+                                }
+                            }
+                        }, DISCONNECT_FALLBACK_DELAY_MS);
+                    }
+                });
+            });
+        }
+        return future;
     }
 
     public boolean isConnected() {
@@ -130,6 +170,25 @@
                     if (!this.connected) {
                         throw new NotConnectedException();
                     }
+
+                    BluetoothGattCharacteristic cached = this.dequeueNotification(uuid);
+                    if (cached != null) {
+                        byte[] value = cached.getValue();
+                        Peripheral.this.wakeCommand(future, value);
+                        return;
+                    }
+
+                    if (this.subscribedNotificationUuids.contains(uuid)) {
+                        LinkedList<SimpleFuture<byte[]>> waiters = this.pendingNotificationReads.computeIfAbsent(
+                                uuid,
+                                ignored -> new LinkedList<>()
+                        );
+                        waiters.add(future);
+                        // Read completion will arrive via onCharacteristicChanged.
+                        // Do not hold command queue while waiting for a notification.
+                        this.runNextCommand();
+                        return;
+                    }
 
                     BluetoothGattCharacteristic characteristic = this.getCharacteristicByUuid(uuid);
                     this.setCommandCallback(new CommandCallback() {
@@ -180,6 +239,13 @@
                     BluetoothGattCharacteristic characteristic = this.getCharacteristicByUuid(uuid);
                     characteristic.setValue(data);
                     characteristic.setWriteType(writeType);
+                    // WRITE_TYPE_NO_RESPONSE may not trigger onCharacteristicWrite callback
+                    // on all Android stacks. Complete immediately so command queue can continue.
+                    if (writeType == BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE) {
+                        this.writeNoResponseWithRetry(future, characteristic, 0);
+                        return;
+                    }
+
                     this.setCommandCallback(new CommandCallback() {
                         @Override
                         public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
@@ -206,6 +272,7 @@
                             });
                         }
                     });
+
                     if (!this.gatt.writeCharacteristic(characteristic)) {
                         throw new RuntimeException("Unable to write characteristic");
                     }
@@ -213,6 +280,39 @@
             });
         }
         return future;
+    }
+
+    @SuppressLint("MissingPermission")
+    private void writeNoResponseWithRetry(
+            SimpleFuture<Void> future,
+            BluetoothGattCharacteristic characteristic,
+            int attempt
+    ) {
+        if (!this.connected || this.gatt == null) {
+            throw new RuntimeException("Disconnected while in write operation");
+        }
+
+        if (this.gatt.writeCharacteristic(characteristic)) {
+            Peripheral.this.wakeCommand(future, null);
+            return;
+        }
+
+        int nextAttempt = attempt + 1;
+        if (nextAttempt >= WRITE_NO_RESPONSE_MAX_RETRIES) {
+            throw new RuntimeException("Unable to write characteristic");
+        }
+
+        this.handler.postDelayed(() -> {
+            synchronized (Peripheral.this) {
+                Peripheral.this.asyncWithFuture(future, () ->
+                        Peripheral.this.writeNoResponseWithRetry(
+                                future,
+                                characteristic,
+                                nextAttempt
+                        )
+                );
+            }
+        }, WRITE_NO_RESPONSE_RETRY_DELAY_MS);
     }
 
     @SuppressLint("MissingPermission")
@@ -275,10 +375,6 @@
 
                     BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIGURATION_DESCRIPTOR);
                     descriptor.setValue(enable ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.DISABLE_NOTIFICATION_VALUE);
-                    if (!this.gatt.writeDescriptor(descriptor)) {
-                        throw new RuntimeException("Unable to write client characteristic configuration descriptor");
-                    }
-
                     this.setCommandCallback(new CommandCallback() {
                         @Override
                         public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
@@ -291,6 +387,13 @@
                                     throw new UnexpectedCharacteristicException();
                                 }
 
+                                if (enable) {
+                                    Peripheral.this.subscribedNotificationUuids.add(uuid);
+                                } else {
+                                    Peripheral.this.subscribedNotificationUuids.remove(uuid);
+                                    Peripheral.this.notificationBacklog.removeIf(c -> c.getUuid().equals(uuid));
+                                    Peripheral.this.pendingNotificationReads.remove(uuid);
+                                }
                                 Peripheral.this.wakeCommand(future, null);
                             });
                         }
@@ -309,6 +412,10 @@
                             });
                         }
                     });
+
+                    if (!this.gatt.writeDescriptor(descriptor)) {
+                        throw new RuntimeException("Unable to write client characteristic configuration descriptor");
+                    }
                 });
             });
         }
@@ -408,6 +515,17 @@
         }
 
         throw new NoSuchCharacteristicException();
+    }
+
+    private BluetoothGattCharacteristic dequeueNotification(UUID uuid) {
+        for (java.util.Iterator<BluetoothGattCharacteristic> it = this.notificationBacklog.iterator(); it.hasNext(); ) {
+            BluetoothGattCharacteristic candidate = it.next();
+            if (candidate.getUuid().equals(uuid)) {
+                it.remove();
+                return candidate;
+            }
+        }
+        return null;
     }
 
     @SuppressLint("MissingPermission")
@@ -465,14 +583,22 @@
         @Override
         public void onConnectionStateChange(BluetoothGatt gatt, int status, int newState) {
             synchronized (Peripheral.this) {
-                switch (newState) {
-                    case BluetoothGatt.STATE_CONNECTED:
-                        Peripheral.this.connected = true;
-                        break;
-                    case BluetoothGatt.STATE_DISCONNECTED:
-                        Peripheral.this.connected = false;
-                        break;
-                }
+                switch (newState) {
+                    case BluetoothGatt.STATE_CONNECTED:
+                        Peripheral.this.connected = true;
+                        break;
+                    case BluetoothGatt.STATE_DISCONNECTED:
+                        Peripheral.this.connected = false;
+                        Peripheral.this.notificationBacklog.clear();
+                        for (LinkedList<SimpleFuture<byte[]>> waiters : Peripheral.this.pendingNotificationReads.values()) {
+                            while (!waiters.isEmpty()) {
+                                waiters.removeFirst().wakeWithThrowable(new NotConnectedException());
+                            }
+                        }
+                        Peripheral.this.pendingNotificationReads.clear();
+                        Peripheral.this.subscribedNotificationUuids.clear();
+                        break;
+                }
                 if (Peripheral.this.commandCallback != null) {
                     Peripheral.this.commandCallback.onConnectionStateChange(gatt, status, newState);
                 }
@@ -519,15 +645,34 @@
             BluetoothGattCharacteristic characteristic2 = new BluetoothGattCharacteristic(characteristic.getUuid(), characteristic.getProperties(), characteristic.getPermissions());
             characteristic2.setValue(characteristic.getValue());
             synchronized (Peripheral.this) {
+                SimpleFuture<byte[]> pendingRead = null;
+                LinkedList<SimpleFuture<byte[]>> waiters = Peripheral.this.pendingNotificationReads.get(characteristic.getUuid());
+                if (waiters != null && !waiters.isEmpty()) {
+                    pendingRead = waiters.removeFirst();
+                    if (waiters.isEmpty()) {
+                        Peripheral.this.pendingNotificationReads.remove(characteristic.getUuid());
+                    }
+                } else {
+                    Peripheral.this.notificationBacklog.add(characteristic2);
+                    while (Peripheral.this.notificationBacklog.size() > MAX_NOTIFICATION_BACKLOG) {
+                        Peripheral.this.notificationBacklog.removeFirst();
+                    }
+                }
+
                 for (WeakReference<QueueStream<BluetoothGattCharacteristic>> ref : Peripheral.this.notificationStreams) {
                     QueueStream<BluetoothGattCharacteristic> stream = ref.get();
                     if (stream != null) {
                         stream.add(characteristic2);
                     }
                 }
-            }
-        }
 
+                if (pendingRead != null) {
+                    byte[] pendingValue = characteristic2.getValue();
+                    pendingRead.wake(pendingValue == null ? new byte[0] : pendingValue);
+                }
+            }
+        }
+
         @Override
         public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
             synchronized (Peripheral.this) {
@@ -536,6 +681,15 @@
                 }
             }
         }
+
+        @Override
+        public void onMtuChanged(BluetoothGatt gatt, int mtu, int status) {
+            synchronized (Peripheral.this) {
+                if (Peripheral.this.commandCallback != null) {
+                    Peripheral.this.commandCallback.onMtuChanged(gatt, mtu, status);
+                }
+            }
+        }
     }
 
     private static abstract class CommandCallback extends BluetoothGattCallback {
